/* --- Output generated by lang compiler. Do Not Edit --- */
#include "core/core.h"

struct __hittable;
struct __hittable_vtable;
extern struct __hittable_vtable __hittable_vtable_inst;
struct __sphere;
struct __sphere_vtable;
extern struct __sphere_vtable __sphere_vtable_inst;
struct __io__File;
struct __io__File_vtable;
extern struct __io__File_vtable __io__File_vtable_inst;
struct __Object {
	struct __Object_vtable* _vtable;
};
struct __Object_vtable {
	struct _lang_vtable_head _header;
	void (*destruct)(void*);
	bool (*_op_equals)(void*, struct __Object*);
	long (*to_hash)(void*);
	_lang_array* (*to_string)(void*);
};

struct __io__File {
	struct __Object _super;
	struct __Object* _cfile;
};
struct __io__File_vtable {
	struct __Object_vtable _vtable_super;
	void (*putc)(void*, char);
	void (*print)(void*, _lang_array*);
	void (*println)(void*, _lang_array*);
	_lang_array* (*read)(void*, long);
	void (*flush)(void*);
	char (*getc)(void*);
	_lang_array* (*readln)(void*);
	void (*close)(void*);
};

struct __vec3;
struct __vec3_vtable;
extern struct __vec3_vtable __vec3_vtable_inst;
struct __Object;
struct __Object_vtable;
extern struct __Object_vtable __Object_vtable_inst;
struct __hittable_list;
struct __hittable_list_vtable;
extern struct __hittable_list_vtable __hittable_list_vtable_inst;
struct __ray;
struct __ray_vtable;
extern struct __ray_vtable __ray_vtable_inst;
struct __hit_record;
struct __hit_record_vtable;
extern struct __hit_record_vtable __hit_record_vtable_inst;
struct __camera;
struct __camera_vtable;
extern struct __camera_vtable __camera_vtable_inst;
struct __hittable {
	struct __Object _super;
};
struct __hittable_vtable {
	struct __Object_vtable _vtable_super;
	bool (*hit)(void*, struct __ray*, double, double, struct __hit_record*);
};

struct __sphere {
	struct __hittable _super;
	struct __vec3* center;
	double radius;
};
struct __sphere_vtable {
	struct __hittable_vtable _vtable_super;
};

struct __vec3 {
	struct __Object _super;
	double e0;
	double e1;
	double e2;
};
struct __vec3_vtable {
	struct __Object_vtable _vtable_super;
	double (*b)(void*);
	struct __vec3* (*_op_div)(void*, double);
	double (*g)(void*);
	double (*length)(void*);
	double (*dot)(void*, struct __vec3*);
	struct __vec3* (*cross)(void*, struct __vec3*);
	double (*squared_length)(void*);
	struct __vec3* (*make_unit_vector)(void*);
	struct __vec3* (*mul_vec3)(void*, struct __vec3*);
	struct __vec3* (*_op_sub)(void*, struct __vec3*);
	double (*_op_array)(void*, long);
	double (*r)(void*);
	struct __vec3* (*_op_add)(void*, struct __vec3*);
	struct __vec3* (*_op_mul)(void*, double);
	double (*x)(void*);
	double (*y)(void*);
	double (*z)(void*);
	struct __vec3* (*div_vec3)(void*, struct __vec3*);
};

struct __hittable_list {
	struct __hittable _super;
	_lang_array* list;
};
struct __hittable_list_vtable {
	struct __hittable_vtable _vtable_super;
};

struct __ray {
	struct __Object _super;
	struct __vec3* a;
	struct __vec3* b;
};
struct __ray_vtable {
	struct __Object_vtable _vtable_super;
	struct __vec3* (*origin)(void*);
	struct __vec3* (*point_at_parameter)(void*, double);
	struct __vec3* (*direction)(void*);
};

struct __hit_record {
	struct __Object _super;
	struct __vec3* p;
	struct __vec3* normal;
	double t;
};
struct __hit_record_vtable {
	struct __Object_vtable _vtable_super;
};

struct __camera {
	struct __Object _super;
	struct __vec3* horizontal;
	struct __vec3* origin;
	struct __vec3* vertical;
	struct __vec3* lower_left_corner;
};
struct __camera_vtable {
	struct __Object_vtable _vtable_super;
	struct __ray* (*get_ray)(void*, double, double);
};

void __Object_construct(void *);
void __Object_destruct(void *);
long __Object_to_hash(void *);
_lang_array* __Object_to_string(void *);
bool __Object__op_equals(void *, struct __Object*);
struct __Object* __Object(void *);
void __io__File_construct(void *, _lang_array*, _lang_array*);
void __io__File_destruct(void *);
void __io__File_putc(void *, char);
void __io__File_print(void *, _lang_array*);
void __io__File_println(void *, _lang_array*);
char __io__File_getc(void *);
_lang_array* __io__File_read(void *, long);
_lang_array* __io__File_readln(void *);
void __io__File_flush(void *);
void __io__File_close(void *);
_lang_array* __io__File_to_string(void *);
struct __io__File* __io__File(void *, _lang_array*, _lang_array*);
extern const struct __io__File* __io__stdout;
extern const struct __io__File* __io__stdin;
extern const struct __io__File* __io__stderr;
double __math__sqrt(void *, double);
long __math__rand(void *);
double __math__rand_double(void *);
float __toFloat(void *, long);
int __toInt(void *, double);
double __toDouble(void *, long);
long __toLong(void *, double);
void __vec3_construct(void *, double, double, double);
double __vec3_x(void *);
double __vec3_y(void *);
double __vec3_z(void *);
double __vec3_r(void *);
double __vec3_g(void *);
double __vec3_b(void *);
struct __vec3* __vec3__op_add(void *, struct __vec3*);
struct __vec3* __vec3__op_sub(void *, struct __vec3*);
double __vec3__op_array(void *, long);
struct __vec3* __vec3__op_mul(void *, double);
struct __vec3* __vec3__op_div(void *, double);
struct __vec3* __vec3_mul_vec3(void *, struct __vec3*);
struct __vec3* __vec3_div_vec3(void *, struct __vec3*);
double __vec3_squared_length(void *);
double __vec3_length(void *);
struct __vec3* __vec3_make_unit_vector(void *);
double __vec3_dot(void *, struct __vec3*);
struct __vec3* __vec3_cross(void *, struct __vec3*);
_lang_array* __vec3_to_string(void *);
struct __vec3* __vec3(void *, double, double, double);
void __ray_construct(void *, struct __vec3*, struct __vec3*);
struct __vec3* __ray_origin(void *);
struct __vec3* __ray_direction(void *);
struct __vec3* __ray_point_at_parameter(void *, double);
struct __ray* __ray(void *, struct __vec3*, struct __vec3*);
void __hit_record_construct(void *, double, struct __vec3*, struct __vec3*);
struct __hit_record* __hit_record(void *, double, struct __vec3*, struct __vec3*);
void __hittable_construct(void *);
bool __hittable_hit(void *, struct __ray*, double, double, struct __hit_record*);
struct __hittable* __hittable(void *);
void __sphere_construct(void *, struct __vec3*, double);
bool __sphere_hit(void *, struct __ray*, double, double, struct __hit_record*);
struct __sphere* __sphere(void *, struct __vec3*, double);
void __hittable_list_construct(void *, _lang_array*);
bool __hittable_list_hit(void *, struct __ray*, double, double, struct __hit_record*);
struct __hittable_list* __hittable_list(void *, _lang_array*);
void __camera_construct(void *);
struct __ray* __camera_get_ray(void *, double, double);
struct __camera* __camera(void *);
struct __vec3* __random_in_unit_sphere(void *);
struct __vec3* __color(void *, struct __ray*, struct __hittable*);
void __main(void *);
float __toFloat(void *_data, long i) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
const float f = (float)(i);
return (float)(f);
}

int __toInt(void *_data, double f) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
const int i = (int)(f);
return (int)(i);
}

double __toDouble(void *_data, long i) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
const double f = (double)(i);
return (double)(f);
}

long __toLong(void *_data, double f) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
const long i = (long)(f);
return (long)(i);
}

void __vec3_construct(void *_data, double e0i, double e1i, double e2i) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
((((struct __vec3*)_data)))->e0 = (double)(e0i);
((((struct __vec3*)_data)))->e1 = (double)(e1i);
((((struct __vec3*)_data)))->e2 = (double)(e2i);
}

double __vec3_x(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(((((struct __vec3*)_data)))->e0);
}

double __vec3_y(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(((((struct __vec3*)_data)))->e1);
}

double __vec3_z(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(((((struct __vec3*)_data)))->e2);
}

double __vec3_r(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(((((struct __vec3*)_data)))->e0);
}

double __vec3_g(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(((((struct __vec3*)_data)))->e1);
}

double __vec3_b(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(((((struct __vec3*)_data)))->e2);
}

struct __vec3* __vec3__op_add(void *_data, struct __vec3* other) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)((((((struct __vec3*)_data)))->e0+((other))->e0)), (double)((((((struct __vec3*)_data)))->e1+((other))->e1)), (double)((((((struct __vec3*)_data)))->e2+((other))->e2))));
}

struct __vec3* __vec3__op_sub(void *_data, struct __vec3* other) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)((((((struct __vec3*)_data)))->e0-((other))->e0)), (double)((((((struct __vec3*)_data)))->e1-((other))->e1)), (double)((((((struct __vec3*)_data)))->e2-((other))->e2))));
}

double __vec3__op_array(void *_data, long i) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
if((bool)(((i==0)))) {
return (double)(((((struct __vec3*)_data)))->e0);
}
else if((bool)(((i==1)))) {
return (double)(((((struct __vec3*)_data)))->e1);
}
else if((bool)(((i==2)))) {
return (double)(((((struct __vec3*)_data)))->e2);
}
else {
return (double)(0.0);
}
}

struct __vec3* __vec3__op_mul(void *_data, double s) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)((((((struct __vec3*)_data)))->e0*s)), (double)((((((struct __vec3*)_data)))->e1*s)), (double)((((((struct __vec3*)_data)))->e2*s))));
}

struct __vec3* __vec3__op_div(void *_data, double s) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)((((((struct __vec3*)_data)))->e0/s)), (double)((((((struct __vec3*)_data)))->e1/s)), (double)((((((struct __vec3*)_data)))->e2/s))));
}

struct __vec3* __vec3_mul_vec3(void *_data, struct __vec3* o) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)((((((struct __vec3*)_data)))->e0*((o))->e0)), (double)((((((struct __vec3*)_data)))->e1*((o))->e1)), (double)((((((struct __vec3*)_data)))->e2*((o))->e2))));
}

struct __vec3* __vec3_div_vec3(void *_data, struct __vec3* o) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)((((((struct __vec3*)_data)))->e0/((o))->e0)), (double)((((((struct __vec3*)_data)))->e1/((o))->e1)), (double)((((((struct __vec3*)_data)))->e2/((o))->e2))));
}

double __vec3_squared_length(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)((((((((struct __vec3*)_data)))->e0*((((struct __vec3*)_data)))->e0)+(((((struct __vec3*)_data)))->e1*((((struct __vec3*)_data)))->e1))+(((((struct __vec3*)_data)))->e2*((((struct __vec3*)_data)))->e2)));
}

double __vec3_length(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)(__math__sqrt(NULL, (double)((_lang_temp_this0 = (((struct __vec3*)_data)), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->squared_length(_lang_temp_this0)))));
}

struct __vec3* __vec3_make_unit_vector(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)((_lang_temp_this0 = (((struct __vec3*)_data)), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_mul(_lang_temp_this0, (double)((1.0/(_lang_temp_this1 = (((struct __vec3*)_data)), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->length(_lang_temp_this1)))))));
}

double __vec3_dot(void *_data, struct __vec3* other) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (double)((((((((struct __vec3*)_data)))->e0*((other))->e0)+(((((struct __vec3*)_data)))->e1*((other))->e1))+(((((struct __vec3*)_data)))->e2*((other))->e2)));
}

struct __vec3* __vec3_cross(void *_data, struct __vec3* o) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(__vec3(NULL, (double)(((((((struct __vec3*)_data)))->e1*((o))->e2)-(((((struct __vec3*)_data)))->e2*((o))->e1))), (double)(((((((struct __vec3*)_data)))->e2*((o))->e0)-(((((struct __vec3*)_data)))->e0*((o))->e2))), (double)(((((((struct __vec3*)_data)))->e0*((o))->e1)-(((((struct __vec3*)_data)))->e1*((o))->e0)))));
}

_lang_array* __vec3_to_string(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (_lang_array*)(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_make_string("vec3: x: "), _lang_float_to_string(((((struct __vec3*)_data)))->e0), false), _lang_make_string(", y: "), false), _lang_float_to_string(((((struct __vec3*)_data)))->e1), false), _lang_make_string(", z: "), false), _lang_float_to_string(((((struct __vec3*)_data)))->e2), false));
}

struct __vec3* __vec3(void * _data, double arg0, double arg1, double arg2) {
struct __vec3* _obj = _lang_gc_alloc(sizeof(struct __vec3));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__vec3_vtable_inst;
__vec3_construct(_obj,  arg0,  arg1,  arg2);
return _obj;
}

struct __vec3_vtable __vec3_vtable_inst = {
.b = &__vec3_b,
._op_div = &__vec3__op_div,
.g = &__vec3_g,
.length = &__vec3_length,
.dot = &__vec3_dot,
.cross = &__vec3_cross,
.squared_length = &__vec3_squared_length,
.make_unit_vector = &__vec3_make_unit_vector,
.mul_vec3 = &__vec3_mul_vec3,
._op_sub = &__vec3__op_sub,
._op_array = &__vec3__op_array,
.r = &__vec3_r,
._op_add = &__vec3__op_add,
._op_mul = &__vec3__op_mul,
.x = &__vec3_x,
.y = &__vec3_y,
.z = &__vec3_z,
.div_vec3 = &__vec3_div_vec3,
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__vec3_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__Object_vtable_inst,
},
},
};
void _lang_make_gc_desk__vec3() {
((struct _lang_vtable_head*)(&__vec3_vtable_inst))->gc.size = sizeof(struct __vec3);
((struct _lang_vtable_head*)(&__vec3_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __vec3)/sizeof(void *));
((struct _lang_vtable_head*)(&__vec3_vtable_inst))->gc.is_pointer = is_pointer;}

void __ray_construct(void *_data, struct __vec3* a_v, struct __vec3* b_v) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
((((struct __ray*)_data)))->a = (struct __vec3*)(a_v);
((((struct __ray*)_data)))->b = (struct __vec3*)(b_v);
}

struct __vec3* __ray_origin(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(((((struct __ray*)_data)))->a);
}

struct __vec3* __ray_direction(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)(((((struct __ray*)_data)))->b);
}

struct __vec3* __ray_point_at_parameter(void *_data, double t) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __vec3*)((_lang_temp_this0 = (((((struct __ray*)_data)))->a), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_add(_lang_temp_this0, (struct __vec3*)((_lang_temp_this1 = (((((struct __ray*)_data)))->b), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->_op_mul(_lang_temp_this1, (double)(t)))))));
}

struct __ray* __ray(void * _data, struct __vec3* arg0, struct __vec3* arg1) {
struct __ray* _obj = _lang_gc_alloc(sizeof(struct __ray));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__ray_vtable_inst;
__ray_construct(_obj,  arg0,  arg1);
return _obj;
}

struct __ray_vtable __ray_vtable_inst = {
.origin = &__ray_origin,
.point_at_parameter = &__ray_point_at_parameter,
.direction = &__ray_direction,
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__Object_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__Object_vtable_inst,
},
},
};
void _lang_make_gc_desk__ray() {
((struct _lang_vtable_head*)(&__ray_vtable_inst))->gc.size = sizeof(struct __ray);
((struct _lang_vtable_head*)(&__ray_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __ray)/sizeof(void *));
((struct _lang_vtable_head*)(&__ray_vtable_inst))->gc.is_pointer = is_pointer;is_pointer[offsetof(struct __ray, a)/sizeof(void *)] = 1;
is_pointer[offsetof(struct __ray, b)/sizeof(void *)] = 1;
}

void __hit_record_construct(void *_data, double t, struct __vec3* p, struct __vec3* normal) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
((((struct __hit_record*)_data)))->p = (struct __vec3*)(p);
((((struct __hit_record*)_data)))->t = (double)(t);
((((struct __hit_record*)_data)))->normal = (struct __vec3*)(normal);
}

struct __hit_record* __hit_record(void * _data, double arg0, struct __vec3* arg1, struct __vec3* arg2) {
struct __hit_record* _obj = _lang_gc_alloc(sizeof(struct __hit_record));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__hit_record_vtable_inst;
__hit_record_construct(_obj,  arg0,  arg1,  arg2);
return _obj;
}

struct __hit_record_vtable __hit_record_vtable_inst = {
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__Object_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__Object_vtable_inst,
},
},
};
void _lang_make_gc_desk__hit_record() {
((struct _lang_vtable_head*)(&__hit_record_vtable_inst))->gc.size = sizeof(struct __hit_record);
((struct _lang_vtable_head*)(&__hit_record_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __hit_record)/sizeof(void *));
((struct _lang_vtable_head*)(&__hit_record_vtable_inst))->gc.is_pointer = is_pointer;is_pointer[offsetof(struct __hit_record, p)/sizeof(void *)] = 1;
is_pointer[offsetof(struct __hit_record, normal)/sizeof(void *)] = 1;
}

void __hittable_construct(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
}

bool __hittable_hit(void *_data, struct __ray* r, double t_min, double t_max, struct __hit_record* rec) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (bool)((false));
}

struct __hittable* __hittable(void * _data) {
struct __hittable* _obj = _lang_gc_alloc(sizeof(struct __hittable));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__hittable_vtable_inst;
__hittable_construct(_obj);
return _obj;
}

struct __hittable_vtable __hittable_vtable_inst = {
.hit = &__hittable_hit,
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__Object_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__Object_vtable_inst,
},
},
};
void _lang_make_gc_desk__hittable() {
((struct _lang_vtable_head*)(&__hittable_vtable_inst))->gc.size = sizeof(struct __hittable);
((struct _lang_vtable_head*)(&__hittable_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __hittable)/sizeof(void *));
((struct _lang_vtable_head*)(&__hittable_vtable_inst))->gc.is_pointer = is_pointer;}

void __sphere_construct(void *_data, struct __vec3* cen, double r) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
((((struct __sphere*)_data)))->center = (struct __vec3*)(cen);
((((struct __sphere*)_data)))->radius = (double)(r);
}

bool __sphere_hit(void *_data, struct __ray* r, double t_min, double t_max, struct __hit_record* rec) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
struct __vec3* oc = (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->origin(_lang_temp_this1))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_sub(_lang_temp_this0, (struct __vec3*)(((((struct __sphere*)_data)))->center))));
double a = (double)((_lang_temp_this0 = ((_lang_temp_this1 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->direction(_lang_temp_this1))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->dot(_lang_temp_this0, (struct __vec3*)((_lang_temp_this2 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this2)->_vtable))->direction(_lang_temp_this2))))));
double b = (double)((_lang_temp_this0 = (oc), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->dot(_lang_temp_this0, (struct __vec3*)((_lang_temp_this1 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->direction(_lang_temp_this1))))));
double c = (double)(((_lang_temp_this0 = (oc), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->dot(_lang_temp_this0, (struct __vec3*)(oc)))-(((((struct __sphere*)_data)))->radius*((((struct __sphere*)_data)))->radius)));
double discriminant = (double)(((b*b)-(a*c)));
if((bool)(((discriminant>0)))) {
double temp = (double)((((-b)-__math__sqrt(NULL, (double)(discriminant)))/a));
if((bool)((((bool)(((temp<t_max)))&&(bool)(((temp>t_min))))))) {
((rec))->t = (double)(temp);
((rec))->p = (struct __vec3*)((_lang_temp_this0 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->point_at_parameter(_lang_temp_this0, (double)(((rec))->t))));
((rec))->normal = (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = (((rec))->p), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->_op_sub(_lang_temp_this1, (struct __vec3*)(((((struct __sphere*)_data)))->center)))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_div(_lang_temp_this0, (double)(((((struct __sphere*)_data)))->radius))));
return (bool)((true));
}
temp = (double)((((-b)+__math__sqrt(NULL, (double)(discriminant)))/a));
if((bool)((((bool)(((temp<t_max)))&&(bool)(((temp>t_min))))))) {
((rec))->t = (double)(temp);
((rec))->p = (struct __vec3*)((_lang_temp_this0 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->point_at_parameter(_lang_temp_this0, (double)(((rec))->t))));
((rec))->normal = (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = (((rec))->p), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->_op_sub(_lang_temp_this1, (struct __vec3*)(((((struct __sphere*)_data)))->center)))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_div(_lang_temp_this0, (double)(((((struct __sphere*)_data)))->radius))));
return (bool)((true));
}
}
return (bool)((false));
}

struct __sphere* __sphere(void * _data, struct __vec3* arg0, double arg1) {
struct __sphere* _obj = _lang_gc_alloc(sizeof(struct __sphere));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__sphere_vtable_inst;
__sphere_construct(_obj,  arg0,  arg1);
return _obj;
}

struct __sphere_vtable __sphere_vtable_inst = {
._vtable_super = {
.hit = &__sphere_hit,
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__Object_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__hittable_vtable_inst,
},
},
},
};
void _lang_make_gc_desk__sphere() {
((struct _lang_vtable_head*)(&__sphere_vtable_inst))->gc.size = sizeof(struct __sphere);
((struct _lang_vtable_head*)(&__sphere_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __sphere)/sizeof(void *));
((struct _lang_vtable_head*)(&__sphere_vtable_inst))->gc.is_pointer = is_pointer;is_pointer[offsetof(struct __sphere, center)/sizeof(void *)] = 1;
}

void __hittable_list_construct(void *_data, _lang_array* objs) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
((((struct __hittable_list*)_data)))->list = (_lang_array*)(objs);
}

bool __hittable_list_hit(void *_data, struct __ray* r, double t_min, double t_max, struct __hit_record* rec) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
bool hit = (bool)((false));
double closest = (double)(t_max);
for (long i = (long)(0);
(bool)(((i<(((((struct __hittable_list*)_data)))->list->len)))); (i++)) {
if((bool)(((_lang_temp_this0 = (((struct __hittable**)((((((struct __hittable_list*)_data)))->list)->vals))[i]), ((struct __hittable_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->hit(_lang_temp_this0, (struct __ray*)(r), (double)(t_min), (double)(closest), (struct __hit_record*)(rec)))))) {
hit = (bool)((true));
closest = (double)(((rec))->t);
}
}
return (bool)((hit));
}

struct __hittable_list* __hittable_list(void * _data, _lang_array* arg0) {
struct __hittable_list* _obj = _lang_gc_alloc(sizeof(struct __hittable_list));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__hittable_list_vtable_inst;
__hittable_list_construct(_obj,  arg0);
return _obj;
}

struct __hittable_list_vtable __hittable_list_vtable_inst = {
._vtable_super = {
.hit = &__hittable_list_hit,
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__Object_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__hittable_vtable_inst,
},
},
},
};
void _lang_make_gc_desk__hittable_list() {
((struct _lang_vtable_head*)(&__hittable_list_vtable_inst))->gc.size = sizeof(struct __hittable_list);
((struct _lang_vtable_head*)(&__hittable_list_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __hittable_list)/sizeof(void *));
((struct _lang_vtable_head*)(&__hittable_list_vtable_inst))->gc.is_pointer = is_pointer;is_pointer[offsetof(struct __hittable_list, list)/sizeof(void *)] = 1;
}

void __camera_construct(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
((((struct __camera*)_data)))->lower_left_corner = (struct __vec3*)(__vec3(NULL, (double)(-2.0), (double)(-1.0), (double)(-1.0)));
((((struct __camera*)_data)))->horizontal = (struct __vec3*)(__vec3(NULL, (double)(4.0), (double)(0.0), (double)(0.0)));
((((struct __camera*)_data)))->vertical = (struct __vec3*)(__vec3(NULL, (double)(0.0), (double)(2.0), (double)(0.0)));
((((struct __camera*)_data)))->origin = (struct __vec3*)(__vec3(NULL, (double)(0.0), (double)(0.0), (double)(0.0)));
}

struct __ray* __camera_get_ray(void *_data, double u, double v) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
return (struct __ray*)(__ray(NULL, (struct __vec3*)(((((struct __camera*)_data)))->origin), (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = ((_lang_temp_this2 = (((((struct __camera*)_data)))->lower_left_corner), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this2)->_vtable))->_op_add(_lang_temp_this2, (struct __vec3*)((_lang_temp_this3 = (((((struct __camera*)_data)))->horizontal), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this3)->_vtable))->_op_mul(_lang_temp_this3, (double)(u))))))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->_op_add(_lang_temp_this1, (struct __vec3*)((_lang_temp_this4 = (((((struct __camera*)_data)))->vertical), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this4)->_vtable))->_op_mul(_lang_temp_this4, (double)(v))))))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_sub(_lang_temp_this0, (struct __vec3*)(((((struct __camera*)_data)))->origin))))));
}

struct __camera* __camera(void * _data) {
struct __camera* _obj = _lang_gc_alloc(sizeof(struct __camera));
((struct __Object *)_obj)->_vtable = (struct __Object_vtable *)&__camera_vtable_inst;
__camera_construct(_obj);
return _obj;
}

struct __camera_vtable __camera_vtable_inst = {
.get_ray = &__camera_get_ray,
._vtable_super = {
.destruct = &__Object_destruct,
._op_equals = &__Object__op_equals,
.to_hash = &__Object_to_hash,
.to_string = &__Object_to_string,
._header = {
.gc = {.type = OBJECT, .size = 0, .is_pointer = NULL},
.parent_vtable = &__Object_vtable_inst,
},
},
};
void _lang_make_gc_desk__camera() {
((struct _lang_vtable_head*)(&__camera_vtable_inst))->gc.size = sizeof(struct __camera);
((struct _lang_vtable_head*)(&__camera_vtable_inst))->gc.type = OBJECT;
bool * is_pointer = _lang_gc_calloc_gc_desk_space(sizeof(struct __camera)/sizeof(void *));
((struct _lang_vtable_head*)(&__camera_vtable_inst))->gc.is_pointer = is_pointer;is_pointer[offsetof(struct __camera, horizontal)/sizeof(void *)] = 1;
is_pointer[offsetof(struct __camera, origin)/sizeof(void *)] = 1;
is_pointer[offsetof(struct __camera, vertical)/sizeof(void *)] = 1;
is_pointer[offsetof(struct __camera, lower_left_corner)/sizeof(void *)] = 1;
}

struct __vec3* __random_in_unit_sphere(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
struct __vec3* p = NULL;
do {
p = (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = (__vec3(NULL, (double)(__math__rand_double(NULL)), (double)(__math__rand_double(NULL)), (double)(__math__rand_double(NULL)))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->_op_mul(_lang_temp_this1, (double)(0.5)))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_sub(_lang_temp_this0, (struct __vec3*)(__vec3(NULL, (double)(1), (double)(1), (double)(1))))));
} while ((bool)((((_lang_temp_this2 = (p), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this2)->_vtable))->squared_length(_lang_temp_this2))>=1.0))));
return (struct __vec3*)(p);
}

struct __vec3* __color(void *_data, struct __ray* r, struct __hittable* world) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
struct __hit_record* rec = (struct __hit_record*)(__hit_record(NULL, (double)(0.0), (struct __vec3*)(__vec3(NULL, (double)(0.0), (double)(0.0), (double)(0.0))), (struct __vec3*)(__vec3(NULL, (double)(0.0), (double)(0.0), (double)(0.0)))));
if((bool)(((_lang_temp_this0 = (world), ((struct __hittable_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->hit(_lang_temp_this0, (struct __ray*)(r), (double)(0.0), (double)(1000.0), (struct __hit_record*)(rec)))))) {
return (struct __vec3*)((_lang_temp_this0 = (__vec3(NULL, (double)(((_lang_temp_this1 = (((rec))->normal), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->x(_lang_temp_this1))+1)), (double)(((_lang_temp_this2 = (((rec))->normal), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this2)->_vtable))->y(_lang_temp_this2))+1)), (double)(((_lang_temp_this3 = (((rec))->normal), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this3)->_vtable))->z(_lang_temp_this3))+1)))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_mul(_lang_temp_this0, (double)(0.5))));
}
else {
struct __vec3* unit_dir = (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = (r), ((struct __ray_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->direction(_lang_temp_this1))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->make_unit_vector(_lang_temp_this0)));
double t = (double)((0.5*((_lang_temp_this0 = (unit_dir), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->y(_lang_temp_this0))+1.0)));
return (struct __vec3*)((_lang_temp_this0 = ((_lang_temp_this1 = (__vec3(NULL, (double)(1.0), (double)(1.0), (double)(1.0))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this1)->_vtable))->_op_mul(_lang_temp_this1, (double)((1.0-t))))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_add(_lang_temp_this0, (struct __vec3*)((_lang_temp_this2 = (__vec3(NULL, (double)(0.5), (double)(0.7), (double)(1.0))), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this2)->_vtable))->_op_mul(_lang_temp_this2, (double)(t)))))));
}
}

void __main(void *_data) {void *_lang_temp_this0, *_lang_temp_this1, *_lang_temp_this2, *_lang_temp_this3, *_lang_temp_this4, *_lang_temp_this5, *_lang_temp_this6, *_lang_temp_this7, *_lang_temp_this8;
long nx = (long)(800);
long ny = (long)(400);
long ns = (long)(10);
(_lang_temp_this0 = (__io__stdout), ((struct __io__File_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->print(_lang_temp_this0, (_lang_array*)(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_make_string("P3\n"), _lang_num_to_string(nx), false), _lang_make_string(" "), false), _lang_num_to_string(ny), false), _lang_make_string("\n255\n"), false))));
_lang_array* objs = _lang_array_make_empty(true, sizeof(struct __hittable*));
objs = (_lang_array*)(_lang_array_add_pointer(objs, __sphere(NULL, (struct __vec3*)(__vec3(NULL, (double)(0), (double)(0), (double)(-1))), (double)(0.5))));
objs = (_lang_array*)(_lang_array_add_pointer(objs, __sphere(NULL, (struct __vec3*)(__vec3(NULL, (double)(0), (double)(-100.5), (double)(-1))), (double)(100))));
struct __hittable_list* world = (struct __hittable_list*)(__hittable_list(NULL, (_lang_array*)(objs)));
struct __camera* cam = (struct __camera*)(__camera(NULL));
for (long j = (long)((ny-1));
(bool)(((j>=0))); (j--)) {
for (long i = (long)(0);
(bool)(((i<nx))); (i++)) {
struct __vec3* col = (struct __vec3*)(__vec3(NULL, (double)(0), (double)(0), (double)(0)));
for (long s = (long)(0);
(bool)(((s<ns))); (s++)) {
double u = (double)(((__toDouble(NULL, (long)(i))+__math__rand_double(NULL))/__toDouble(NULL, (long)(nx))));
double v = (double)(((__toDouble(NULL, (long)(j))+__math__rand_double(NULL))/__toDouble(NULL, (long)(ny))));
struct __ray* r = (struct __ray*)((_lang_temp_this0 = (cam), ((struct __camera_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->get_ray(_lang_temp_this0, (double)(u), (double)(v))));
col = (struct __vec3*)((_lang_temp_this0 = (col), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_add(_lang_temp_this0, (struct __vec3*)(__color(NULL, (struct __ray*)(r), (struct __hittable*)(world))))));
}
col = (struct __vec3*)((_lang_temp_this0 = (col), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_div(_lang_temp_this0, (double)(__toDouble(NULL, (long)(ns))))));
col = (struct __vec3*)((_lang_temp_this0 = (col), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->_op_mul(_lang_temp_this0, (double)(255.99))));
int ir = (int)(__toInt(NULL, (double)((_lang_temp_this0 = (col), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->r(_lang_temp_this0)))));
int ig = (int)(__toInt(NULL, (double)((_lang_temp_this0 = (col), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->g(_lang_temp_this0)))));
int ib = (int)(__toInt(NULL, (double)((_lang_temp_this0 = (col), ((struct __vec3_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->b(_lang_temp_this0)))));
(_lang_temp_this0 = (__io__stdout), ((struct __io__File_vtable *)(((struct __Object *)_lang_temp_this0)->_vtable))->print(_lang_temp_this0, (_lang_array*)(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_array_cat(_lang_num_to_string(ir), _lang_make_string(" "), false), _lang_num_to_string(ig), false), _lang_make_string(" "), false), _lang_num_to_string(ib), false), _lang_make_string("\n"), false))));
}
}
}

int main (int argc, char **argv) {
_lang_init();
_lang_make_gc_desk__hittable();
_lang_make_gc_desk__sphere();
_lang_make_gc_desk__io__File();
_lang_make_gc_desk__vec3();
_lang_make_gc_desk__Object();
_lang_make_gc_desk__hittable_list();
_lang_make_gc_desk__ray();
_lang_make_gc_desk__hit_record();
_lang_make_gc_desk__camera();
__main(NULL);
};
